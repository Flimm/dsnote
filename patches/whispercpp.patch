diff -ruN a/ggml.c b/ggml.c
--- a/ggml.c	2023-04-10 22:18:29.000000000 +0200
+++ b/ggml.c	2023-04-11 10:39:38.651600772 +0200
@@ -2689,6 +2689,7 @@
     void * mem_buffer;
     bool   mem_buffer_owned;
     bool   no_alloc;
+    bool   stop;
 
     int    n_objects;
 
@@ -2993,6 +2994,14 @@
     return ctx;
 }
 
+void ggml_cancel(struct ggml_context * ctx) {
+    ctx->stop = true;
+}
+
+void ggml_cancel_clear(struct ggml_context * ctx) {
+    ctx->stop = false;
+}
+
 void ggml_free(struct ggml_context * ctx) {
     // make this function thread safe
     ggml_critical_section_start();
@@ -9707,7 +9716,7 @@
     const int64_t perf_start_cycles  = ggml_perf_cycles();
     const int64_t perf_start_time_us = ggml_perf_time_us();
 
-    for (int i = 0; i < cgraph->n_nodes; i++) {
+    for (int i = 0; i < cgraph->n_nodes && !ctx->stop; i++) {
         GGML_PRINT_DEBUG_5("%s: %d/%d\n", __func__, i, cgraph->n_nodes);
 
         struct ggml_tensor * node = cgraph->nodes[i];
@@ -9737,7 +9746,7 @@
                 atomic_store(&state_shared.has_work, false);
             }
 
-            while (atomic_load(&state_shared.has_work)) {
+            while (atomic_load(&state_shared.has_work) && !ctx->stop) {
                 ggml_lock_lock  (&state_shared.spin);
                 ggml_lock_unlock(&state_shared.spin);
             }
@@ -9756,7 +9765,7 @@
 
             atomic_fetch_sub(&state_shared.n_ready, 1);
 
-            while (atomic_load(&state_shared.n_ready) > 0) {
+            while (atomic_load(&state_shared.n_ready) > 0 && !ctx->stop) {
                 ggml_lock_lock  (&state_shared.spin);
                 ggml_lock_unlock(&state_shared.spin);
             }
@@ -9773,14 +9782,14 @@
                 atomic_store(&state_shared.has_work, false);
             }
 
-            while (atomic_load(&state_shared.has_work)) {
+            while (atomic_load(&state_shared.has_work) && !ctx->stop) {
                 ggml_lock_lock  (&state_shared.spin);
                 ggml_lock_unlock(&state_shared.spin);
             }
 
             atomic_fetch_sub(&state_shared.n_ready, 1);
 
-            while (atomic_load(&state_shared.n_ready) != 0) {
+            while (atomic_load(&state_shared.n_ready) != 0 && !ctx->stop) {
                 ggml_lock_lock  (&state_shared.spin);
                 ggml_lock_unlock(&state_shared.spin);
             }
@@ -9792,7 +9801,7 @@
                 atomic_store(&state_shared.has_work, false);
             }
 
-            while (atomic_load(&state_shared.has_work)) {
+            while (atomic_load(&state_shared.has_work) && !ctx->stop) {
                 ggml_lock_lock  (&state_shared.spin);
                 ggml_lock_unlock(&state_shared.spin);
             }
@@ -9811,7 +9820,7 @@
 
             atomic_fetch_sub(&state_shared.n_ready, 1);
 
-            while (atomic_load(&state_shared.n_ready) > 0) {
+            while (atomic_load(&state_shared.n_ready) > 0 && !ctx->stop) {
                 ggml_lock_lock  (&state_shared.spin);
                 ggml_lock_unlock(&state_shared.spin);
             }
@@ -9828,14 +9837,14 @@
                 atomic_store(&state_shared.has_work, false);
             }
 
-            while (atomic_load(&state_shared.has_work)) {
+            while (atomic_load(&state_shared.has_work) && !ctx->stop) {
                 ggml_lock_lock  (&state_shared.spin);
                 ggml_lock_unlock(&state_shared.spin);
             }
 
             atomic_fetch_sub(&state_shared.n_ready, 1);
 
-            while (atomic_load(&state_shared.n_ready) != 0) {
+            while (atomic_load(&state_shared.n_ready) != 0 && !ctx->stop) {
                 ggml_lock_lock  (&state_shared.spin);
                 ggml_lock_unlock(&state_shared.spin);
             }
diff -ruN a/ggml.h b/ggml.h
--- a/ggml.h	2023-04-10 22:18:29.000000000 +0200
+++ b/ggml.h	2023-04-11 10:20:00.982826499 +0200
@@ -353,6 +353,8 @@
 
 struct ggml_context * ggml_init(struct ggml_init_params params);
 void ggml_free(struct ggml_context * ctx);
+void ggml_cancel(struct ggml_context * ctx);
+void ggml_cancel_clear(struct ggml_context * ctx);
 
 size_t ggml_used_mem(const struct ggml_context * ctx);
 
diff -ruN a/whisper.cpp b/whisper.cpp
--- a/whisper.cpp	2023-04-10 22:18:29.000000000 +0200
+++ b/whisper.cpp	2023-04-11 10:41:26.283738355 +0200
@@ -595,6 +595,9 @@
     // [EXPERIMENTAL] speed-up techniques
     int32_t exp_n_audio_ctx = 0; // 0 - use default
 
+    bool stop = false;
+    ggml_context * gctx = nullptr;
+
     void use_buf(struct ggml_context * ctx, int i) {
 #if defined(WHISPER_USE_SCRATCH)
         size_t last_size = 0;
@@ -1359,6 +1362,8 @@
     };
 
     struct ggml_context * ctx0 = ggml_init(params);
+    wctx.state->gctx = ctx0;
+    if (wctx.state->stop) ggml_cancel(ctx0);
 
     wstate.use_buf(ctx0, 0);
 
@@ -1749,16 +1754,17 @@
         ggml_graph_compute(ctx0, &gf);
         //ggml_graph_print(&gf);
     }
-
+    
     ////////////////////////////////////////////////////////////////////////////
 
-    //printf("%s: used_mem = %f MB, %f MB, %f MB %f MB %f MB\n", __func__,
-    //        ggml_used_mem(ctx0)/1024.0/1024.0,
-    //        wstate.get_buf_max_mem(0)/1024.0/1024.0,
-    //        wstate.get_buf_max_mem(1)/1024.0/1024.0,
-    //        wstate.get_buf_max_mem(2)/1024.0/1024.0,
-    //        wstate.get_buf_max_mem(3)/1024.0/1024.0);
+    // printf("%s: used_mem = %f MB, %f MB, %f MB %f MB %f MB\n", __func__,
+    //         ggml_used_mem(ctx0)/1024.0/1024.0,
+    //         wstate.get_buf_max_mem(0)/1024.0/1024.0,
+    //         wstate.get_buf_max_mem(1)/1024.0/1024.0,
+    //         wstate.get_buf_max_mem(2)/1024.0/1024.0,
+    //         wstate.get_buf_max_mem(3)/1024.0/1024.0);
 
+    wctx.state->gctx = nullptr;
     ggml_free(ctx0);
 
     wstate.t_encode_us += ggml_time_us() - t_start_us;
@@ -3916,6 +3922,8 @@
             return -6;
         }
 
+        if (ctx->state->stop) return -100;
+
         // if there is a very short audio segment left to process, we remove any past prompt since it tends
         // to confuse the decoder and often make it repeat or hallucinate stuff
         if (seek > seek_start && seek + 500 >= seek_end) {
@@ -3999,6 +4007,8 @@
                     return -7;
                 }
 
+                if (ctx->state->stop) return -100;
+
                 {
                     const int64_t t_start_sample_us = ggml_time_us();
 
@@ -4237,6 +4247,8 @@
                         return -8;
                     }
 
+                    if (ctx->state->stop) return -100;
+
                     {
                         const int64_t t_start_sample_us = ggml_time_us();
 
@@ -4436,9 +4448,19 @@
         }
     }
 
+    if (ctx->state->stop) return -100;
+
     return 0;
 }
 
+void whisper_cancel(struct whisper_context * ctx) {
+    ctx->state->stop = true;
+    if (ctx->state->gctx) ggml_cancel(ctx->state->gctx);
+}
+
+void whisper_cancel_clear(struct whisper_context * ctx) {
+    ctx->state->stop = false;
+}
 
 int whisper_full(
         struct whisper_context * ctx,
@@ -5070,7 +5092,7 @@
             }
         }
     }
-
+    
     // fixed token expand (optional)
     //{
     //    const int t_expand = 0;
diff -ruN a/whisper.h b/whisper.h
--- a/whisper.h	2023-04-10 22:18:29.000000000 +0200
+++ b/whisper.h	2023-04-11 10:24:49.443208488 +0200
@@ -114,6 +114,10 @@
     WHISPER_API void whisper_free      (struct whisper_context * ctx);
     WHISPER_API void whisper_free_state(struct whisper_state * state);
 
+    // Cancel any ongoing operation
+    WHISPER_API void whisper_cancel(struct whisper_context * ctx);
+    WHISPER_API void whisper_cancel_clear(struct whisper_context * ctx);
+
     // Convert RAW PCM audio to log mel spectrogram.
     // The resulting spectrogram is stored inside the default state of the provided whisper context.
     // Returns 0 on success
